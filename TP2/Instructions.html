 <!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<!-- saved from url=(0072)https://perso.telecom-paristech.fr/hudry/optim/descentEnglish/index.html -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  
  <title>TPDescente</title>
  <meta name="generator" content="LibreOffice 4.3.3.2 (Linux)">
  <meta name="created" content="00:00:00">
  <meta name="changedby" content="Olivier Hudry">
  <meta name="changed" content="2016-04-12T13:59:18.995623332">
  <meta name="Originator" content="Microsoft Word 11">
  <meta name="ProgId" content="Word.Document">
<!--[if gte mso 9]><xml> <o:DocumentProperties> <o:Author>Hudry</o:Author> <o:LastAuthor>Hudry</o:LastAuthor> <o:Revision>3</o:Revision> <o:TotalTime>1</o:TotalTime> <o:Created>2012-10-18T13:53:00Z</o:Created> <o:LastSaved>2012-10-18T13:54:00Z</o:LastSaved> <o:Pages>1</o:Pages> <o:Words>1291</o:Words> <o:Characters>7106</o:Characters> <o:Company>ENST</o:Company> <o:Lines>59</o:Lines> <o:Paragraphs>16</o:Paragraphs> <o:CharactersWithSpaces>8381</o:CharactersWithSpaces> <o:Version>11.8107</o:Version> </o:DocumentProperties> </xml><![endif]--><!--[if gte mso 9]><xml> <w:WordDocument> <w:HyphenationZone>21</w:HyphenationZone> <w:ValidateAgainstSchemas/> <w:SaveIfXMLInvalid>false</w:SaveIfXMLInvalid> <w:IgnoreMixedContent>false</w:IgnoreMixedContent> <w:AlwaysShowPlaceholderText>false</w:AlwaysShowPlaceholderText> <w:BrowserLevel>MicrosoftInternetExplorer4</w:BrowserLevel> </w:WordDocument> </xml><![endif]--><!--[if gte mso 9]><xml> <w:LatentStyles DefLockedState="false" LatentStyleCount="156"> </w:LatentStyles> </xml><![endif]--><!--[if gte mso 10]> <style> /* Style Definitions */ table.MsoNormalTable {mso-style-name:"Tableau Normal"; mso-tstyle-rowband-size:0; mso-tstyle-colband-size:0; mso-style-noshow:yes; mso-style-parent:""; mso-padding-alt:0cm 5.4pt 0cm 5.4pt; mso-para-margin:0cm; mso-para-margin-bottom:.0001pt; mso-pagination:widow-orphan; font-size:10.0pt; font-family:"Times New Roman"; mso-ansi-language:#0400; mso-fareast-language:#0400; mso-bidi-language:#0400;} </style> <![endif]--><!--[if gte mso 9]><xml> <o:shapedefaults v:ext="edit" spidmax="2050"/> </xml><![endif]--><!--[if gte mso 9]><xml> <o:shapelayout v:ext="edit"> <o:idmap v:ext="edit" data="1"/> </o:shapelayout></xml><![endif]-->
  <style type="text/css">
p { color: #000000 }
h1 { color: #000000 }
h2 { color: #000000 }
h2.cjk { font-family: "Droid Sans Fallback" }
h2.ctl { font-family: "FreeSans" }
a:link { color: #0000ff }
a:visited { color: #0000ff }
  </style>
</head>
<body style="background: none 0% 50% repeat scroll rgb(238, 238, 238); direction: ltr; color: rgb(0, 0, 0);" lang="fr-FR" link="#0000ff" vlink="#0000ff">
<h1 align="center">Practical work on the descent method</h1>
<p><br>
<br>
The aim is to program in Java a descent method in the following
particular case.</p>
<p>We consider a function <span style="font-style: italic;">f</span>
of two real variables and a domain <span style="font-style: italic;">D</span>
of the plane delimited by linear functions. We assume that <span style="font-style: italic;">f</span> is convex
and continuously differentiable on an open set containing <span style="font-style: italic;">D</span>. We search the
minimum of the function <span style="font-style: italic;">f
</span>&nbsp;on <span style="font-style: italic;">D</span>.<br>
<br>
The problem could be for example:<br>
&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; Minimize the
function <i>f</i>(<i>x</i>, <i>y</i>)
= exp(<i>x</i> + <i>y</i>) + <i>x</i><sup>2</sup>
+ 2 <i>y</i><sup>2<br>
</sup>&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; in the domain defined by:
&nbsp;&nbsp;&nbsp;−2<i>x</i> + <i>y&nbsp;</i>≤
0<br>
&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp; &nbsp; &nbsp;&nbsp;&nbsp; &nbsp; <i>&nbsp;</i>−<i>y</i>&nbsp;≤
0<br>
&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;
&nbsp;&nbsp; &nbsp; <i>&nbsp; &nbsp; x</i>
+ <i>y</i>
≤ 4<br>
</p>
<p>It will be necessary to complete a Java class of a program.</p>
<p><font color="#000000">The constraints of the
problem are modeled as <span style="font-weight: bold;">negativity
constraints</span>, in the form <span style="font-style: italic;">ax</span>
+ <span style="font-style: italic;">by</span> + <span style="font-style: italic;">c</span> ≤ 0. The </font><font color="#000000">gradient</font><font color="#000000">
</font><font color="#000000">vector</font><font color="#000000"> </font><font color="#000000">computed
by the </font><font style="font-family: Courier New,Courier,monospace;" color="#000000">getGradient(</font><font style="font-family: Courier New,Courier,monospace;" color="#000000">)</font><font color="#000000">
method of the&nbsp;class</font><font color="#000000">
</font><font style="font-family: Courier New,Courier,monospace;" color="#000000">Constraint</font><span style="font-family: Courier New,Courier,monospace;"> </span><font color="#000000">is </font><font color="#000000">the
vector (<span style="font-style: italic;">a</span>, <span style="font-style: italic;">b</span>).</font></p>
<p>If you want to see the result to achieve, download<p__>&nbsp;<a href="https://perso.telecom-paristech.fr/hudry/optim/descentEnglish/executableDescent.jar">executableDescent.jar</a>.
You can then run the program with the command <br>
<span style="font-family: Courier New,Courier,monospace;">java
-jar executableDescent.jar</span>. </p__></p>
<p>To run the application, it is necessary to choose a problem by
providing a number between 1 and 14; after validating the problem, the
domain is displayed; you must then choose a starting point for the
descent method inside the domain and then press the "Start" button. The
descent method runs. During the method, for each point obtained during
the method, the gradient vector is drawn in blue and the next direction
to follow is in green. The trajectory generated by the descent method
is drawn in red along the way.</p>
<p>You must start by saving the file&nbsp;<a href="https://perso.telecom-paristech.fr/hudry/optim/descentEnglish/descentToDo.jar">descentToDo.jar</a>
on your computer.&nbsp;</p>
<p>After launching Eclipse, to create the project:
</p>
<ul>
  <li>in "File", do New then Java Project: this opens a window;</li>
  <li>in the "Project name" framework, put the name of your choice;</li>
  <li>if the "JRE" box in the window displays "jdk-11.0.19" to the
right, go directly to the last instruction in this list;&nbsp;</li>
  <li>otherwise, do all of the following:</li>
  <li>in the JRE framework, select "Use a project specific JRE"; on the
right, click on "Configure JREs..." (under the two small frames): this
opens a window called "Preferences"</li>
  <li>in the "Preferences" window, click on the "Add" button: this
opens a window called "Add JRE";</li>
  <li>&nbsp;in the "Add JRE" window, select "Standard VM" then click on
"Next": this opens a new window called "Add JRE";</li>
  <li>in "JRE home", write /cal/softs/java/jdk-11.0.19/ then click on
Finish:
this returns to the "Preferences" window; then click on "Apply and
close";
this returns to the "New Java Project" window;</li>
  <li>in the JRE framework, at the (selected) line "Use a project
specific
JRE", choose "jdk-11.0.19" using the black triangle pointed down;</li>
  <li>click on the "Finish" button at the bottom; this opens a "New
module-info.java"
window;&nbsp; in this window, choose <span style="font-weight: bold; color: rgb(255, 0, 0);">"Don't
create" in order NOT TO CREATE A MODULE</span>.</li>
</ul>
<ul>
</ul>
<ul>
</ul>
<p>If you work on your computer, maybe you must choose not to use any
"module" in the page where the name of the project is given.<br>
<br>
Then :</p>
<ul>
  <li>click on <span style="color: rgb(255, 0, 0);">src</span> under
the name of the project with the&nbsp;right button
and
choose "import"; </li>
  <li>in the obtained window, in "General", choose "Archive
File"; </li>
  <li>after doing "Next", browse to choose descentToComplete.jar; </li>
  <li>click on finish.</li>
</ul>
<p>You can try to run the method <font face="Courier New">main</font>
which is in the class <font face="Courier New">Main</font>
of the package <font face="Courier New">descent</font>.</p>
<p>The work to be done consists only of completing the
class&nbsp;<font face="Courier New">Descent</font>&nbsp;of
the package
<font face="Courier New">descent.model</font>. In
this class, six
methods are to be completed (see the comments in the file to be
completed for the description of these methods; these comments precede
each of the methods to be completed): for the method <font style="color: rgb(51, 0, 51);" color="#000000"><font face="Courier New">direction</font></font><font style="color: rgb(51, 0, 51);" color="#ff0000"><font face="Courier New">ToFollowIfPOn</font></font><font style="color: rgb(51, 0, 51);" color="#ff0000"><font face="Courier New">Corner</font></font><font color="#000000"><font face="monospace"><span style="font-family: Times New Roman;"><span style="color: rgb(51, 0, 51);">,</span>&nbsp;</span></font></font><font color="#000000">explanations are provided below on this page.</font></p>
<ul>
  <li>
    <p style="margin-bottom: 0cm;">the method <font color="#ff0000"><font face="Courier New">directionToFollowIfPInside</font></font>; </p>
  </li>
  <li>
    <p style="margin-bottom: 0cm;">the method&nbsp;<font color="#ff0000"><font face="Courier New">directionToFollowIfPOnEdge</font></font>; </p>
  </li>
  <li>
    <p style="margin-bottom: 0cm;">the method&nbsp;<font color="#ff0000"><font face="Courier New">directionToFollowIfPOn</font></font><font color="#ff0000"><font face="Courier New">Corner</font></font>;</p>
  </li>
  <li>
    <p style="margin-bottom: 0cm;">the method&nbsp;<font color="#ff0000"><font face="Courier New">searchSecondPoint</font></font>;</p>
  </li>
  <li>
    <p style="margin-bottom: 0cm;">the method&nbsp;<font color="#ff0000"><font face="Courier New">dichotomy</font></font>; </p>
  </li>
  <li>
    <p>the method&nbsp;<font color="#ff0000"><font face="Courier New">KarushKuhnTucker</font></font>.
    </p>
  </li>
</ul>
<p>If the gradient norm of the studied function is lower than the
attribute <span style="font-family: Courier New;">threshold
</span>of the class <span style="font-family: Courier New;">descent</span>,
the descent method is considered to be over; other cases of termination
occur when the current point <span style="font-family: Courier New;">P</span>
is on an edge or on a corner of the domain.</p>
<p>
<font color="#000000">It will be necessary to pay
attention to the following attributes of the class </font><font style="font-family: Courier New;" color="#000000">Descent</font><font color="#000000"><span style="font-family: Courier New;"></span>:</font></p>
<ul>
  <li>
    <p style="margin-bottom: 0cm;">the attribute <font style="font-family: Courier New;" face="monospace">direction </font>must
contain the direction to be followed by the
descent method from the current point; </p>
  </li>
  <li>
    <p>the&nbsp;attribute <span style="font-family: Courier New,Courier,monospace;">finished</span>
should be set to <span style="font-family: Courier New,Courier,monospace;">true</span>
when you consider that the method is over. </p>
  </li>
</ul>
<p><font style="font-size: 14pt;">Explanations for
the
function</font><font color="#000000"><font style="font-size: 14pt;">&nbsp;</font></font><font style="color: rgb(51, 51, 51);" color="#ff0000"><font face="Courier New">directionToFollowIfPOn</font></font><font style="color: rgb(51, 51, 51);" color="#ff0000"><font face="Courier New">Corner</font></font>
</p>
<p class="msonormal"><img style="border: 0px solid ; width: 548px; height: 404px;" alt="figure 1" src="./Instructions_files/fig1.png" name="Image1">&nbsp; <img style="border: 0px solid ; width: 463px; height: 403px;" alt="figure 2" src="./Instructions_files/fig2.png" name="Image2"></p>
<p>In the drawings, two cases are represented: the case of an
obtuse
corner and the case of an acute corner. In both cases, the current
point P is on the corner. The border lines of the constraints are
called c<sub>1</sub>
and c<sub>2</sub>. The feasible domain lies between these
two lines. The non-feasible domain is shaded.&nbsp;</p>
<p>The vector n<sub>1</sub> is equal to&nbsp;−∇<span style="font-style: italic;">g</span><sub>1</sub>(P) if the first
constraint is <span style="font-style: italic;">g</span><sub>1</sub>(<span style="font-style: italic;">x</span>, <span style="font-style: italic;">y</span>)&nbsp;≤ &nbsp;0;&nbsp;
&nbsp;the vector n<sub>2</sub> is equal to&nbsp;−∇<span style="font-style: italic;">g</span><sub>2</sub>(P)&nbsp;if the second
constraint is <span style="font-style: italic;"></span> <span style="font-style: italic;">g</span><sub>2</sub>(<span style="font-style: italic;">x</span>, <span style="font-style: italic;">y</span>)&nbsp;≤ &nbsp;0.</p>
<p>
The vectors u<sub>1</sub> and u<sub>2</sub> are
the unitary vectors of the borders and are located inside
the&nbsp;feasible domain: <b>u</b><sub style="font-weight: bold;">1</sub><b>
must be
oriented towards the negative side of the constraint c</b><sub style="font-weight: bold;">2</sub> (it is necessary that the scalar
product
of u<sub>1</sub> with n<sub>2</sub> is
positive), <b>u</b><sub style="font-weight: bold;">2</sub><b>&nbsp;</b><b>must
be</b><b> oriented towards the negative side of the constraint c</b><sub style="font-weight: bold;">1</sub> (it is necessary that the scalar
product
of u<sub>2</sub> with n<sub>1</sub> is
positive).</p>
<p>Let ∇<i>f</i> &nbsp;be the gradient of <i>f</i>
at the point P.&nbsp;<br>
</p>
<ul>
  <li>
    <p><i>First case</i>:&nbsp;∇<i>f</i>
belongs to zone 1, in shaded blue. The steepest feasible direction is
−∇<i>f</i>.&nbsp;The&nbsp;decomposition of&nbsp;∇<i>f</i>
with respect to the vectors<i> </i>u<sub>1</sub> and<i> </i>u<sub>2</sub>&nbsp;
allows to detect this case.</p>
  </li>
</ul>
<ul>
  <li>
    <p><i>Second case</i>:&nbsp;∇<i>f</i>&nbsp;belongs
to zone 2, in pink (shaded or not), the condition of Karush, Kuhn
and Tucker is fulfilled. The&nbsp;decomposition of&nbsp;∇<i>f</i>
with respect to the vectors<i> </i>n<sub>1</sub> and<i> </i>n<sub>2</sub>&nbsp;
allows to detect this case. </p>
  </li>
</ul>
<ul>
  <li>
    <p><i>Third case</i>:&nbsp; we are not in the
previous two&nbsp;cases and so&nbsp;∇<i>f</i>belongs
to zone 3, green, or zone 4, yellow, shaded or not. In this case, the
steepest feasible direction is given by&nbsp;one of the two
vectors&nbsp;u<sub>1</sub> or u<sub>2</sub>. Remind that the greater
angle a direction <span style="font-style: italic;">d</span> makes
with&nbsp;∇<span style="font-style: italic;">f</span> (i.e.
smaller the scalar product of <span style="font-style: italic;">d</span>
with&nbsp;∇<span style="font-style: italic;">f</span>&nbsp; is),
the more <span style="font-style: italic;">d</span> descends<span style="font-style: italic;"></span>.</p>
  </li>
</ul>
<p><font color="#ff0000"><b>WARNING: do not
change anything outside the Descent class.</b></font></p>
<p></p>
<p><font style="color: rgb(51, 0, 51);" color="#ff0000">You
have a&nbsp;<a href="https://perso.telecom-paristech.fr/hudry/optim/descentEnglish/doc/index.html">documentation
on the project</a> here.</font><br>
<br>
The classes and methods useful for the work to be done are in
particular the following:</p>
<ul>
  <li>
    <p style="margin-bottom: 0cm;">The class <font face="Courier New">descent.model.Descent</font>
models the descent; it is in this class that the six methods to be
completed can be found; explanations are in the file <font face="Courier New">Descent.java</font>
&nbsp;to complete. </p>
  </li>
  <li>
    <p>The class&nbsp;<font face="Courier New">descent.model.Couple </font>models
a couple of two elements of type <font style="font-family: Courier New;" face="monospace">double</font>;
it is used to model a point of the real plane or a vector of this same
plane. The following methods in this class may be useful: </p>
  </li>
</ul>
<ul>
  <ul>
    <li>
      <p style="margin-bottom: 0cm;">the method&nbsp;<font color="#ff0000"><font face="Courier New">double
scalarProduct(Couple v)</font></font>:&nbsp; if <font face="Courier New">v1</font>&nbsp;and <font face="Courier New">v2</font>
are two vectors of
type&nbsp; <font face="Courier New">Couple</font>,
then <font face="Courier New">v1.scalarProduct(v2)</font>
gives the scalar product of <font face="Courier New">v1</font>
with <font face="Courier New">v2</font>; </p>
    </li>
    <li>
      <p style="margin-bottom: 0cm;">the method&nbsp;<font color="#ff0000"><font face="Courier New">double
norm()</font></font>: &nbsp; if <font face="Courier New">v</font> is a
vector of type <font face="Courier New">Couple</font>, then <font face="Courier New">v.norm()</font> gives the norm of <font face="Courier New">v</font>; </p>
    </li>
    <li>
      <p style="margin-bottom: 0cm;">the method&nbsp;<font color="#ff0000"><font face="Courier New">boolean
isPerpendicular(Couple v)</font></font>:&nbsp; if <font face="Courier New">v1</font>&nbsp;and <font face="Courier New">v2</font>
are two vectors of
type&nbsp; <font face="Courier New">Couple</font>,
then <font face="Courier New">v1.isPerpendicular(v2)</font>
is equal to <font face="Courier New">true</font> if <font face="Courier New">v1</font> and <font face="Courier New">v2</font>
are perpendicular, and <font face="Courier New">false</font>
otherwise; </p>
    </li>
    <li>
      <p style="margin-bottom: 0cm;">the method&nbsp;<font color="#ff0000"><font face="Courier New">Couple
mult(double t)</font></font> :&nbsp; if <font face="Courier New">v</font>
is a vector of type <font face="Courier New">Couple</font> and if <font face="Courier New">t</font> is a <span style="font-family: Courier New,Courier,monospace;">double</span>,
then <font face="Courier New">v.mult(t)</font>
return the
vector of type <font face="Courier New">Couple</font>
obtained by multiplying <font face="Courier New">v</font>
by <font face="Courier New">t</font>; <font face="Courier New">v</font>
is not modified by this
multiplication; </p>
    </li>
    <li>
      <p style="margin-bottom: 0cm;">the method&nbsp;<font color="#ff0000"><font face="Courier New">Couple
add(Couple v)</font></font><font face="Courier New">:</font>&nbsp;
if <font face="Courier New">v1</font>&nbsp;and <font face="Courier New">v2</font> are two vectors of
type&nbsp; <font face="Courier New">Couple</font>,
then <font face="Courier New">v1.add(v2)</font>
return the
vector of&nbsp;type <font face="Courier New">Couple</font>
obtained by&nbsp;adding <font face="Courier New">v1</font>
to<font face="Courier New"> v2</font>
; <font face="Courier New">v1</font>&nbsp; is
not modified by this addition; </p>
    </li>
    <li>
      <p style="margin-bottom: 0cm;">the method <font style="font-family: Courier New,Courier,monospace;" color="#ff0000">Couple
decompose(Couple v, Couple v1, Couple
v2)</font><code style="font-family: Courier New,Courier,monospace;"></code><font face="Courier New">:</font>&nbsp; if<code></code> <font face="Courier New">v</font>, <font face="Courier New">v1</font> and <font face="Courier New">v2</font>&nbsp;are three
vectors of type&nbsp; <font face="Courier New">Couple</font>,
then <font color="#000000"><font face="Courier New">decompose</font></font><code><font color="#000000"><font style="font-size: 10pt;">(v,
v1,&nbsp;v2)</font></font></code> returns the two
components of <font face="Courier New">v</font> on
the basis formed by <font face="Courier New">v1</font>
and <font face="Courier New">v2</font>; if <font face="Courier New">v1</font>
and <font face="Courier New">v2</font> are parallel, the method
return null.</p>
    </li>
    <li>
      <p style="margin-bottom: 0cm;"> </p>
    </li>
    <li> </li>
  </ul>
  <li>
    <p style="margin-bottom: 0cm;">The class <font face="Courier New">descent.model.Constraint
    </font>models
a linear constraint that is written: <font face="Courier New">coeffx
* x + coeffy * y + constant
&lt;= 0</font>; this class also models a half-plane. The line
of equation: <font face="Courier New">coeffx * x + coeffy
* y + constant = 0</font> is the&nbsp;border line of the
half-plane. The following methods in this class may be useful: </p>
    <ul>
      <li>
        <p style="margin-bottom: 0cm;">the method<font color="#ff0000"><font face="Courier New">
Couple
getGradient()</font></font>: if <font face="Courier New">c</font>
is of
type <font face="Courier New">Constraint</font>,
then <font face="Courier New">c.getGradient()</font>returns
the gradient of the function<span style="font-family: Courier New,Courier,monospace;"> (x, y) </span>&nbsp;<font face="Courier New">-&gt;</font>&nbsp;<font face="Courier New">coeffx *
x + coeffy * y + constant</font>,
&nbsp;i.e. the vector of components <font face="Courier New">coeffx</font>
and <font face="Courier New">coeffy;</font> </p>
      </li>
      <li>
        <p style="margin-bottom: 0cm;">the method <font color="#ff0000"><font face="Courier New">Couple
getUnitaryEdgeVector</font></font>:&nbsp;if <font face="Courier New">c</font>
is of
type <font face="Courier New">Constraint</font>,
then <font face="Courier New">c.</font><font style="color: rgb(51, 0, 51);" color="#ff0000"><font face="Courier New">getUnitaryEdgeVector</font></font><font face="Courier New">()</font> gives a unit vector of
the border line. </p>
      </li>
    </ul>
  </li>
  <li>
    <p style="margin-bottom: 0cm;">The class <font face="Courier New">descent.model.Domain</font><font face="Courier New"> </font>models a domain defined by
a set of linear constraints. We
suppose that there are not three constraints which intersect at the
same point (otherwise the code might not work). The following methods
in this class may be useful: </p>
    <ul>
      <li>
        <p style="margin-bottom: 0cm;">the method<font color="#ff0000"><font face="Courier New">
Constraint isOnEdge(Couple P)</font></font>:
&nbsp;&nbsp;if <font face="Courier New">D</font>
is of type&nbsp;<font face="Courier New">Domain</font>
and if <font face="Courier New">P</font> is a point
of type <font face="Courier New">Couple</font>,
then: </p>
        <ul>
          <li>
            <p style="margin-bottom: 0cm;">if <font face="Courier New">P</font>
is on an edge of the
domain, <font face="Courier New">D.isOnEdge(P)</font>
returns a constraint (of&nbsp; type <span style="font-family: Courier New,Courier,monospace;">Constraint)</span>
corresponding to this edge; if <span style="font-family: Courier New,Courier,monospace;">P</span>
is on a corner of the domain, the method returns one of the two
constraints corresponding to this corner;</p>
          </li>
          <li>
            <p style="margin-bottom: 0cm;">if <span style="font-family: Courier New;">P</span> is not on an edge of the
domain,&nbsp;<font face="Courier New">D.isOnEdge(P)</font>
returns <font face="Courier New">null</font>; </p>
          </li>
        </ul>
      </li>
      <li>
        <p style="margin-bottom: 0cm;">the method <font color="#ff0000"><font face="Courier New">Constraint[]
isCorner(Couple P)</font></font>: &nbsp;if <font face="Courier New">D</font>
is of type&nbsp;<font face="Courier New">Domain</font> and if <font face="Courier New">P</font> is a point of type <font face="Courier New">Couple</font>, then: </p>
        <ul>
          <li>
            <p style="margin-bottom: 0cm;">if <font face="Courier New">P</font>
is on a corner of the
domain, <font face="Courier New">D.isCorner(P)</font>
returns the two constraints corresponding to this corner (in the form
of an array of type<font face="Courier New"> Constraint[]</font>
with two components); </p>
          </li>
          <li>
            <p style="margin-bottom: 0cm;">si <font face="Courier New">P</font>
is not in a corner, <font face="Courier New">D.isCorner(P)</font>
returns <font face="Courier New">null</font>. </p>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li>
    <p style="margin-bottom: 0cm;">The abstract class <font face="Courier New">problem.Pb</font> models a problem,
with the definition of the function <span style="font-family: Courier New,Courier,monospace;">f</span>
to be minimized and the set of constraints defining the domain. All
problems are defined by classes inheriting from the class <span style="font-family: Courier New,Courier,monospace;">problem.Pb</span>.
The following methods in this class can be used:<br>
    <br>
    </p>
    <div style="text-align: left;">
    <ul>
      <li>the method<font color="#ff0000"><font face="Courier New">
double
gPrime(Couple P0,&nbsp;Couple d, double t)</font></font>:
if <font face="Courier New">pb</font>&nbsp;is
of type <font face="Courier New">Pb</font>, if <span style="font-style: italic;">t</span>&nbsp;<font face="Courier New">-&gt;</font>
        <span style="font-style: italic;">P</span>0 + <span style="font-style: italic;">td</span> (<span style="font-style: italic;">t</span> &gt; 0) is
the parametric equation of a half-line, then <font face="Courier New">pb.gPrime(P0,
d, t) </font>returns the value of the derivative in <font face="Courier New">t</font> of the function <font face="Courier New">g:
t -&gt;
g(t) = pb.f(P0 + td)</font>;</li>
      <li>
        <p>the method<font color="#ff0000">&nbsp;</font><font color="#ff0000"><font face="Courier New">Couple
gradientf(Couple P)</font></font><font color="#000000">:
if </font><font style="font-family: Courier New;" color="#000000">pb</font><font color="#000000"> </font>is of type <font face="Courier New">Pb</font>,
&nbsp;if&nbsp;<font face="Courier New">P</font>
is a point of type <font face="Courier New">Couple</font>,
&nbsp;then <font face="Courier New">pb.gradientf(P</font><span style="font-family: Courier New,Courier,monospace;">)</span>
returns the gradient of <font face="Courier New">f</font>
at the point&nbsp;<font face="Courier New">P</font>.</p>
      </li>
    </ul>
    </div>
  </li>
</ul>
<p>When you have correctly implemented the method&nbsp;<font style="color: rgb(51, 0, 51);" color="#ff0000"><font face="Courier New">directionToFollowIfPInside</font></font>,
you will be able to see what happens with Problem 1 to see if it starts
well; after implementing&nbsp;<font style="color: rgb(51, 0, 51);" color="#ff0000"><font face="Courier New">directionToFollowIfPOnEdge</font></font>,&nbsp;
you will be able to see what happens with Problem 1 to see if it goes
well on one edge; after implementing&nbsp;<font style="color: rgb(51, 0, 51);" color="#ff0000"><font face="Courier New">directionToFollowIfPOn</font></font><span style="font-family: Courier New;">Corner</span>,<span style="font-family: Courier New;">&nbsp;</span>you
will be able to check what happens with Problems 1, 4 and 6.<br>
After implementing the method<font color="#ff0000"><font face="Courier New"> <span style="color: rgb(51, 0, 51);">searchSecondPoint</span></font></font>,
you will be able to see what happens with Problem 3 (which does not
reach a minimum in the domain).<br>
After implementing the method <font face="Courier New">dichotomy</font>,&nbsp;
you will be able to test all the problems.</p>
<!--<h2 class="western">Travail &agrave; rendre</h2>
<p>A la fin de la s&eacute;ance de TP, vous enverrez par
courrier
&eacute;lectronique le fichier Descente.java &agrave;
irene.charon@gmail.com. Le titre
de ce courrier sera n&eacute;cessairement "TP descente Durand"
o&ugrave;
vous remplacerez "Durand" par votre nom (et votre pr&eacute;nom
en cas d'homonymie).</p>-->
<p class="msonormal" style="margin-bottom: 0.42cm;"><br>
<br>
</p>


</body></html>
